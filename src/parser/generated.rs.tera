use rowan:: {
    SyntaxNode,
    TreeArc,
    TransparentNewType,
};

use super::*;


{% for ty in sum_types %}
{%- set typeName = ty.id | camel -%}
#[derive(Debug)]
#[repr(transparent)]
pub(crate) struct {{typeName}}(SyntaxNode);

unsafe impl TransparentNewType for {{ typeName }} {
    type Repr = rowan::SyntaxNode;
}

pub(crate) enum {{ typeName }}Kind<'a> {
{% for c in ty.constructors %}
    {{c.id | camel }}(&'a {{ c.prod_type.id | camel }}),
{%- endfor %}
}
{% for c in ty.constructors %}
impl<'a> From<&'a {{c.id | camel }}> for &'a {{ typeName }} {
    fn from(n: &'a {{c.id | camel }}) -> &'a {{ typeName }} {
        {{ typeName }}::cast(&n.0).unwrap()
    }
}
{% endfor %}
impl {{ typeName }} {

    #[allow(unused)]
    pub(crate) fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            {%- for c in ty.constructors %}
            | {{ c.prod_type.id | SCREAM }}
            {%- endfor %} => Some({{ typeName }}::from_repr(syntax.into_repr())),
            _ => None,
        }
    }

    #[allow(unused)]
    pub(crate) fn kind(&self) -> {{ typeName }}Kind {
        match self.0.kind() {
            {%- for c in ty.constructors %}
            {{ c.prod_type.id | SCREAM }} => {{ typeName }}Kind::{{c.id | camel }}({{ c.prod_type.id | camel }}::cast(&self.0).unwrap()),
            {%- endfor %}
            _ => unreachable!(),
        }
    }

    #[allow(unused)]
    pub(crate) fn to_owned(&self) -> TreeArc<Self> {
        TreeArc::cast(self.0.to_owned())
    }
}

{% endfor %}
{% for ty in prod_types %}
{% set typeName = ty.id | camel %}
#[derive(PartialEq, Eq, Hash, Debug)]
#[repr(transparent)]
pub(crate) struct {{typeName}}(SyntaxNode);

unsafe impl TransparentNewType for {{typeName}} {
    type Repr = rowan::SyntaxNode;
}

impl {{typeName}} {
    {% for f in ty.fields %}
    {% if f.is_option -%}
    #[allow(unused)]
    pub(crate) fn {{f.id | snake}}(&self) -> Option<&{{f.type_id | camel}}> {
        self.0.children().find_map({{f.type_id | camel}}::cast)
    }
    {% elif f.is_sequence -%}
    #[allow(unused)]
    pub(crate) fn {{f.id | snake}}(&self) -> impl Iterator<Item = &{{f.type_id | camel}}> {
        self.0.children().filter_map({{f.type_id | camel}}::cast)
    }
    {% else -%}
    #[allow(unused)]
    pub(crate) fn {{f.id | snake}}(&self) -> &{{f.type_id | camel}} {
        self.0.children().find_map({{f.type_id | camel}}::cast).unwrap()
    }
    {% endif -%}
    {% endfor %}
    #[allow(unused)]
    pub(crate) fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            {{ ty.id | SCREAM }} => Some({{ typeName }}::from_repr(syntax.into_repr())),
            _ => None,
        }
    }

    #[allow(unused)]
    pub(crate) fn to_owned(&self) -> TreeArc<Self> {
        TreeArc::cast(self.0.to_owned())
    }

    #[allow(unused)]
    pub(crate) fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
{%- endfor%}
#[allow(unused)]
pub(crate) fn kind_name(kind: SyntaxKind) -> &'static str {
    match kind {
        {%- for ty in sum_types %}
        {%- for c in ty.constructors %}
        {{ c.prod_type.id | SCREAM }} => "{{ c.prod_type.id | camel }}",
        {%- endfor %}
        {%- endfor %}
        {%- for ty in prod_types %}
        {{ ty.id | SCREAM }} => "{{ ty.id | camel }}",
        {%- endfor %}
        _ => "Undefined"
    }
}