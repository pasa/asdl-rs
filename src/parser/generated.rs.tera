use rowan:: {
    SmolStr,
    SyntaxKind,
    GreenNode,
    GreenNodeBuilder,
    SyntaxElement,
    SyntaxNode,
    SyntaxToken,
    TreeArc,
    TransparentNewType,
    WalkEvent,
};

use super::*;


{% for ty in sum_types %}
{%- set typeName = ty.id | camel -%}
#[derive(Debug)]
#[repr(transparent)]
pub(crate) struct {{typeName}}(SyntaxNode);

unsafe impl TransparentNewType for {{ typeName }} {
    type Repr = rowan::SyntaxNode;
}

pub(crate) enum {{ typeName }}Kind<'a> {
{% for c in ty.constructors %}
    {{c.id | camel }}(&'a {{ c.prod_type.id | camel }}),
{% endfor %}
}

{% for c in ty.constructors %}
impl<'a> From<&'a {{c.id | camel }}> for &'a {{ typeName }} {
    fn from(n: &'a {{c.id | camel }}) -> &'a {{ typeName }} {
        {{ typeName }}::cast(&n.syntax).unwrap()
    }
}
{% endfor %}

impl {{ typeName }} {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            {%- for c in ty.constructors %}
            | {{ c.prod_type.id | SCREAM }}
            {%- endfor %} => Some({{ typeName }}::from_repr(syntax.into_repr())),
            _ => None,
        }
    }

    pub fn kind(&self) -> {{ typeName }}Kind {
        match self.0.kind() {
            {%- for c in ty.constructors %}
            {{ c.prod_type.id | SCREAM }} => {{ typeName }}Kind::{{c.id | camel }}({{ c.prod_type.id | camel }}::cast(&self.syntax).unwrap()),
            {%- endfor %}
            _ => unreachable!(),
        }
    }

    fn to_owned(&self) -> TreeArc<Self> {
        TreeArc::cast(self.0.to_owned())
    }
}
{% endfor %}

{% for ty in prod_types %}
#[derive(PartialEq, Eq, Hash, Debug)]
#[repr(transparent)]
pub(crate) struct {{ty.id | camel}}(SyntaxNode);

impl {{ty.id | camel}} {
    {% for f in ty.fields -%}
    {% if f.is_option %}
    fn {{f.id | snake}}(&self) -> Option<&{{f.type_id | camel}}> {
        self.0.children().find_map({{f.type_id | camel}}::cast)
    }
    {{f.id | snake}}: Option<{{f.type_id | camel}}>
    {% elif f.is_sequence %}
    fn {{f.id | snake}}(&self) -> impl Iterator<Item = &{{f.type_id | camel}}> {
        self.0.children().filter_map({{f.type_id | camel}}::cast)
    }
    {% else %}
    fn {{f.id | snake}}(&self) -> &{{f.type_id | camel}} {
        self.0.children().find_map({{f.type_id | camel}}::cast).unwrap()
    }
    {% endif %}
    {% endfor %}
}
{% endfor %}