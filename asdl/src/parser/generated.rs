//This file is auotgenerated by using `cargo gen-syntax`

#![cfg_attr(rustfmt, rustfmt_skip)]

use super::*;


#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) enum Type<'a> {

    SumType(SumType<'a>),
    ProdType(ProdType<'a>),
}
impl<'a> From<SumType<'a>> for Type<'a> {
    fn from(n: SumType) -> Type {
        Type::SumType(n)
    }
}
impl<'a> From<ProdType<'a>> for Type<'a> {
    fn from(n: ProdType) -> Type {
        Type::ProdType(n)
    }
}




#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct SumType<'a> {
    type_id: TypeId<'a>,
    constructors: Vec<Constr<'a>>,
    attrs: Option<Attrs<'a>>,
}

impl<'a> SumType<'a> {

    pub(crate) fn new(type_id: TypeId<'a>, constructors: Vec<Constr<'a>>, attrs: Option<Attrs<'a>>) -> Self {
        SumType{ type_id, constructors, attrs }
    }
    
    #[allow(dead_code)]
    pub(crate) fn type_id(&self) -> &TypeId {
        &self.type_id
    }
    
    #[allow(dead_code)]
    pub(crate) fn constructors(&self) -> impl Iterator<Item = &Constr> {
        self.constructors.iter()
    }
    
    #[allow(dead_code)]
    pub(crate) fn attrs(&self) -> &Option<Attrs> {
        &self.attrs
    }
}


#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct ProdType<'a> {
    type_id: TypeId<'a>,
    fields: Vec<Field<'a>>,
}

impl<'a> ProdType<'a> {

    pub(crate) fn new(type_id: TypeId<'a>, fields: Vec<Field<'a>>) -> Self {
        ProdType{ type_id, fields }
    }
    
    #[allow(dead_code)]
    pub(crate) fn type_id(&self) -> &TypeId {
        &self.type_id
    }
    
    #[allow(dead_code)]
    pub(crate) fn fields(&self) -> impl Iterator<Item = &Field> {
        self.fields.iter()
    }
}
#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) enum Field<'a> {

    Single(Single<'a>),
    Opt(Opt<'a>),
    Sequence(Sequence<'a>),
}
impl<'a> From<Single<'a>> for Field<'a> {
    fn from(n: Single) -> Field {
        Field::Single(n)
    }
}
impl<'a> From<Opt<'a>> for Field<'a> {
    fn from(n: Opt) -> Field {
        Field::Opt(n)
    }
}
impl<'a> From<Sequence<'a>> for Field<'a> {
    fn from(n: Sequence) -> Field {
        Field::Sequence(n)
    }
}




#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Single<'a> {
    type_id: TypeId<'a>,
    id: Option<Id<'a>>,
}

impl<'a> Single<'a> {

    pub(crate) fn new(type_id: TypeId<'a>, id: Option<Id<'a>>) -> Self {
        Single{ type_id, id }
    }
    
    #[allow(dead_code)]
    pub(crate) fn type_id(&self) -> &TypeId {
        &self.type_id
    }
    
    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &Option<Id> {
        &self.id
    }
}


#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Opt<'a> {
    type_id: TypeId<'a>,
    id: Option<Id<'a>>,
}

impl<'a> Opt<'a> {

    pub(crate) fn new(type_id: TypeId<'a>, id: Option<Id<'a>>) -> Self {
        Opt{ type_id, id }
    }
    
    #[allow(dead_code)]
    pub(crate) fn type_id(&self) -> &TypeId {
        &self.type_id
    }
    
    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &Option<Id> {
        &self.id
    }
}


#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Sequence<'a> {
    type_id: TypeId<'a>,
    id: Option<Id<'a>>,
}

impl<'a> Sequence<'a> {

    pub(crate) fn new(type_id: TypeId<'a>, id: Option<Id<'a>>) -> Self {
        Sequence{ type_id, id }
    }
    
    #[allow(dead_code)]
    pub(crate) fn type_id(&self) -> &TypeId {
        &self.type_id
    }
    
    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &Option<Id> {
        &self.id
    }
}




#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Root<'a> {
    types: Vec<Type<'a>>,
}

impl<'a> Root<'a> {

    pub(crate) fn new(types: Vec<Type<'a>>) -> Self {
        Root{ types }
    }
    
    #[allow(dead_code)]
    pub(crate) fn types(&self) -> impl Iterator<Item = &Type> {
        self.types.iter()
    }
}

#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Constr<'a> {
    id: ConstrId<'a>,
    fields: Vec<Field<'a>>,
}

impl<'a> Constr<'a> {

    pub(crate) fn new(id: ConstrId<'a>, fields: Vec<Field<'a>>) -> Self {
        Constr{ id, fields }
    }
    
    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &ConstrId {
        &self.id
    }
    
    #[allow(dead_code)]
    pub(crate) fn fields(&self) -> impl Iterator<Item = &Field> {
        self.fields.iter()
    }
}

#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Attrs<'a> {
    fields: Vec<Field<'a>>,
}

impl<'a> Attrs<'a> {

    pub(crate) fn new(fields: Vec<Field<'a>>) -> Self {
        Attrs{ fields }
    }
    
    #[allow(dead_code)]
    pub(crate) fn fields(&self) -> impl Iterator<Item = &Field> {
        self.fields.iter()
    }
}
#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct TypeId<'a>(pub(super) &'a str);

impl<'a> TypeId<'a> {

    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &str {
        self.0
    }
}
#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct ConstrId<'a>(pub(super) &'a str);

impl<'a> ConstrId<'a> {

    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &str {
        self.0
    }
}
#[derive(PartialEq, Eq, Hash, Debug)]
pub(crate) struct Id<'a>(pub(super) &'a str);

impl<'a> Id<'a> {

    #[allow(dead_code)]
    pub(crate) fn id(&self) -> &str {
        self.0
    }
}